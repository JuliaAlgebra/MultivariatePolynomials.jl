var documenterSearchIndex = {"docs":
[{"location":"differentiation/#Differentiation","page":"Differentiation","title":"Differentiation","text":"","category":"section"},{"location":"differentiation/","page":"Differentiation","title":"Differentiation","text":"Given a polynomial, say p(x y) = 3x^2y + x + 2y + 1, we can differentiate it by a variable, say x and get partial p(x y)  partial x = 6xy + 1. We can also differentiate it by both of its variable and get the vector 6xy+1 3x^2+1.","category":"page"},{"location":"differentiation/#MultivariatePolynomials.differentiate","page":"Differentiation","title":"MultivariatePolynomials.differentiate","text":"differentiate(p::AbstractPolynomialLike, v::AbstractVariable, deg::Union{Int, Val}=1)\n\nDifferentiate deg times the polynomial p by the variable v.\n\ndifferentiate(p::AbstractPolynomialLike, vs, deg::Union{Int, Val}=1)\n\nDifferentiate deg times the polynomial p by the variables of the vector or tuple of variable vs and return an array of dimension deg. It is recommended to pass deg as a Val instance when the degree is known at compile time, e.g. differentiate(p, v, Val{2}()) instead of differentiate(p, x, 2), as this will help the compiler infer the return type.\n\ndifferentiate(p::AbstractArray{<:AbstractPolynomialLike, N}, vs, deg::Union{Int, Val}=1) where N\n\nDifferentiate the polynomials in p by the variables of the vector or tuple of variable vs and return an array of dimension N+deg. If p is an AbstractVector this returns the Jacobian of p where the i-th row containts the partial derivaties of p[i].\n\nExamples\n\np = 3x^2*y + x + 2y + 1\ndifferentiate(p, x) # should return 6xy + 1\ndifferentiate(p, x, Val{1}()) # equivalent to the above\ndifferentiate(p, (x, y)) # should return [6xy+1, 3x^2+1]\ndifferentiate( [x^2+y, z^2+4x], [x, y, z]) # should return [2x 1 0; 4 0 2z]\n\n\n\n\n\n","category":"function"},{"location":"differentiation/#Antidifferentiation","page":"Differentiation","title":"Antidifferentiation","text":"","category":"section"},{"location":"differentiation/","page":"Differentiation","title":"Differentiation","text":"Given a polynomial, say p(x, y) = 3x^2y + x + 2y + 1, we can antidifferentiate it by a variable, say x and get int_0^x p(X y)mathrmdX = x^3y + 12x^2 + 2xy + x. We can also antidifferentiate it by both of its variable and get the vector [x^3y + 1/2x^2 + 2xy + x, 3/2x^2y^2 + xy + y^2 + y].","category":"page"},{"location":"differentiation/#MultivariatePolynomials.antidifferentiate","page":"Differentiation","title":"MultivariatePolynomials.antidifferentiate","text":"antidifferentiate(p::AbstractPolynomialLike, v::AbstractVariable, deg::Union{Int, Val}=1)\n\nAntidifferentiate deg times the polynomial p by the variable v. The free constant involved by the antidifferentiation is set to 0.\n\nantidifferentiate(p::AbstractPolynomialLike, vs, deg::Union{Int, Val}=1)\n\nAntidifferentiate deg times the polynomial p by the variables of the vector or tuple of variable vs and return an array of dimension deg. It is recommended to pass deg as a Val instance when the degree is known at compile time, e.g. antidifferentiate(p, v, Val{2}()) instead of antidifferentiate(p, x, 2), as this will help the compiler infer the return type.\n\nExamples\n\np = 3x^2*y + x + 2y + 1\nantidifferentiate(p, x) # should return 3x^3* + 1/2*x + 2xy + x\nantidifferentiate(p, x, Val{1}()) # equivalent to the above\nantidifferentiate(p, (x, y)) # should return [3x^3* + 1/2*x + 2xy + x, 3/2x^2*y^2 + xy + y^2 + y]\n\n\n\n\n\n","category":"function"},{"location":"substitution/#Subtitution","page":"Substitution","title":"Subtitution","text":"","category":"section"},{"location":"substitution/","page":"Substitution","title":"Substitution","text":"Given a polynomial, say p(x y) = 3x^2y + x + 2y + 1, one can evaluate it at a given point, e.g. p(2 1) = 12 + 2 + 2 + 1 = 17 or substitute one or more variable by a value or polynomial, e.g. p(x xy^2 + 1) = 3x^2(xy^2+1) + x + 2(xy^2+1) + 1 = 3x^3y^2 + 2xy^2 + 3x^2 + x + 3. We distinguish the two operation as follows","category":"page"},{"location":"substitution/","page":"Substitution","title":"Substitution","text":"We call an evaluation an operation where every variable should be replace by a new value or polynomial, the syntax is p(x => 2, y => 1).\nWe call a subsitution an operation where some (or all variables) are subtituted into a new value or polynomial, the syntax is subs(p, y => x*y^2 + 1).","category":"page"},{"location":"substitution/","page":"Substitution","title":"Substitution","text":"The distinction is important for type stability for some implementations (it is important for DynamicPolynomials but not for TypedPolynomials). Indeed consider a polynomial with Int coefficients for which we ask to replace some variables with Int values. If all the variables are replaced with Ints, the return type should be Int. However, if some variables only are replaced by Int then the return type should be a polynomial with Int coefficients.","category":"page"},{"location":"substitution/#MultivariatePolynomials.subs","page":"Substitution","title":"MultivariatePolynomials.subs","text":"subs(p, s::AbstractSubstitution...)\n\nApply the substitutions s to p. Use p(s...) if we are sure that all the variables are substited in s.\n\nThe allowed substutions are:\n\nv => p where v is a variable and p a polynomial, e.g. x => 1 or x => x^2*y + x + y.\nV => P where V is a tuple or vector of variables and P a tuple or vector of polynomials, e.g. (x, y) => (y, x) or (y, x) => (2, 1).\n\nThe order of the variables is lexicographic with the name with TypedPolynomials and by order of creation with DynamicPolynomials. Since there is no guarantee on the order of the variables, substitution directly with a tuple or a vector is not allowed. You can use p(variables(p) => (1, 2)) instead if you are sure of the order of the variables (e.g. the name order matches the creation order).\n\nExamples\n\np = 3x^2*y + x + 2y + 1\np(x => 2, y => 1) # Return type is Int\nsubs(p, x => 2, y => 1) # Return type is Int in TypedPolynomials but is a polynomial of Int coefficients in DynamicPolynomials\nsubs(p, y => x*y^2 + 1)\np(y => 2) # Do not do that, this works fine with TypedPolynomials but it will not return a correct result with DynamicPolynomials since it thinks that the return type is `Int`.\n\n\n\n\n\n","category":"function"},{"location":"substitution/#MultivariatePolynomials.substitute","page":"Substitution","title":"MultivariatePolynomials.substitute","text":"subs(polynomial, (x, y)=>(1, 2))\n\nis equivalent to:\n\nsubs(polynomial, (x=>1, y=>2))\n\n\n\n\n\n","category":"function"},{"location":"internal/#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"internal/","page":"Internal","title":"Internal","text":"Internal utilities:","category":"page"},{"location":"internal/#MultivariatePolynomials.pair_zip","page":"Internal","title":"MultivariatePolynomials.pair_zip","text":"pair_zip((a, b), (c, d)) gives (a=>c, b=>d)\n\nThis function was written by Fengyang Wang and shared on the Julia discourse forum: https://discourse.julialang.org/t/type-stable-zip-to-pairs/3390/2\n\n\n\n\n\n","category":"function"},{"location":"internal/#Base.vec","page":"Internal","title":"Base.vec","text":"Convert a tuple of variables into a static vector to allow array-like usage. The element type of the vector will be Monomial{vars, length(vars)}.\n\n\n\n\n\n","category":"function"},{"location":"internal/#MultivariatePolynomials.print_maybe_multiplication_sign","page":"Internal","title":"MultivariatePolynomials.print_maybe_multiplication_sign","text":"print_maybe_multiplication_sign(io, mime)\n\nPrints a multiplication sign depending on the mime type.\n\n\n\n\n\n","category":"function"},{"location":"internal/#MultivariatePolynomials.LazyMap","page":"Internal","title":"MultivariatePolynomials.LazyMap","text":"struct LazyMap{T, VT}\n    f::Function\n    data::VT\nend\n\nIterator over the elements of data mapped by f. This is similar to Base.Generator(f, data) except that the eltype of a LazyMap is given at construction while the eltype of Base.Generator(f, data) is Any.\n\n\n\n\n\n","category":"type"},{"location":"division/#Division","page":"Division","title":"Division","text":"","category":"section"},{"location":"division/","page":"Division","title":"Division","text":"Given two polynomials, p and d, there are unique r and q such that p = q d + r and the leading term of d does not divide the leading term of r. You can obtain q using the div function and r using the rem function. The divrem function returns (q r).","category":"page"},{"location":"division/","page":"Division","title":"Division","text":"Given a polynomial p and divisors d_1 ldots d_n, one can find r and q_1 ldots q_n such that p = q_1 d_1 + cdots + q_n d_n + r and none of the leading terms of q_1 ldots q_n divide the leading term of r. You can obtain the vector q_1 ldots q_n using div(p, d) where d = d_1 ldots d_n and r using the rem function with the same arguments. The divrem function returns (q r).","category":"page"},{"location":"division/#MultivariatePolynomials.divides","page":"Division","title":"MultivariatePolynomials.divides","text":"divides(t1::AbstractTermLike, t2::AbstractTermLike)\n\nReturns whether the monomial of t1 divides the monomial of t2.\n\nExamples\n\nCalling divides(2x^2y, 3xy) should return false because x^2y does not divide xy since x has a degree 2 in x^2y which is greater than the degree of x on xy. However, calling divides(3xy, 2x^2y) should return true.\n\n\n\n\n\n","category":"function"},{"location":"division/#MultivariatePolynomials.div_multiple","page":"Division","title":"MultivariatePolynomials.div_multiple","text":"div_multiple(a, b, ma::MA.MutableTrait)\n\nReturn the division of a by b assuming that a is a multiple of b. If a is not a multiple of b then this function may return anything.\n\n\n\n\n\n","category":"function"},{"location":"division/","page":"Division","title":"Division","text":"Note that the coefficients of the polynomials need to be a field for div, rem and divrem to work. If the coefficient type is not a field, it is promoted to a field using promote_to_field.","category":"page"},{"location":"division/#MultivariatePolynomials.promote_to_field","page":"Division","title":"MultivariatePolynomials.promote_to_field","text":"promote_to_field(::Type{T})\n\nPromote the type T to a field. For instance, promote_to_field(T) returns Rational{T} if T is an integer and promote_to_field(T) returns RationalPoly{T} if T is a polynomial.\n\n\n\n\n\n","category":"function"},{"location":"division/","page":"Division","title":"Division","text":"Alternatively, pseudo_rem or pseudo_divrem can be used instead as they do not require the coefficient type to be a field.","category":"page"},{"location":"division/#MultivariatePolynomials.pseudo_rem","page":"Division","title":"MultivariatePolynomials.pseudo_rem","text":"pseudo_rem(f::_APL, g::_APL, algo)\n\nReturn the pseudo remainder of f modulo g as defined in [Knu14, Algorithm R, p. 425].\n\nSee pseudo_divrem for more details.\n\n[Knu14] Knuth, D.E., 2014. Art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley Professional. Third edition.\n\n\n\n\n\n","category":"function"},{"location":"division/#MultivariatePolynomials.pseudo_divrem","page":"Division","title":"MultivariatePolynomials.pseudo_divrem","text":"pseudo_divrem(f::_APL{S}, g::_APL{T}, algo) where {S,T}\n\nReturn the pseudo divisor and remainder of f modulo g as defined in [Knu14, Algorithm R, p. 425].\n\nWhen the coefficient type is not a field, it is not always possible to carry a division. For instance, the division of f = 3x + 1 by g = 2x + 1 cannot be done over integers. On the other hand, one can write 2f = 3g - 1. In general, the pseudo division of f by g is:\n\nl f(x) = q(x) g(x) + r(x)\n\nwhere l is a power of the leading coefficient of g some constant.\n\nSee also pseudo_rem.\n\n[Knu14] Knuth, D.E., 2014. Art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley Professional. Third edition.\n\n\n\n\n\n","category":"function"},{"location":"division/#MultivariatePolynomials.rem_or_pseudo_rem","page":"Division","title":"MultivariatePolynomials.rem_or_pseudo_rem","text":"rem_or_pseudo_rem(f::_APL, g::_APL, algo)\n\nIf the coefficient type is a field, return rem, otherwise, return pseudo_rem.\n\n\n\n\n\n","category":"function"},{"location":"division/#Greatest-Common-Divisor-(GCD)","page":"Division","title":"Greatest Common Divisor (GCD)","text":"","category":"section"},{"location":"division/","page":"Division","title":"Division","text":"The Greatest Common Divisor (GCD) and Least Common Multiple (LCM) can be obtained for integers respectively with the gcd and lcm functions. The same functions can be used with monomials and polynomials:","category":"page"},{"location":"division/#Base.gcd","page":"Division","title":"Base.gcd","text":"gcd(m1::AbstractMonomialLike, m2::AbstractMonomialLike)\n\nReturn the largest monomial m such that both divides(m, m1) and divides(m, m2) are true.\n\njulia> @polyvar x y z;\n\njulia> gcd(x^2*y^7*z^3, x^4*y^5*z^2)\nx²y⁵z²\n\n\n\n\n\nfunction gcd(p1::AbstractPolynomialLike{T}, p2::AbstractPolynomialLike{S}) where {T, S}\n\nReturns a greatest common divisor of p1 and p2. Note that it does not make sense, in general, to speak of \"the\" greatest common divisor of u and v; there is a set of greatest common divisors, each one being a unit multiple of the others [Knu14, p. 424].\n\nImplementation notes\n\nThe classical algorithm for computing the gcd, commonly referred to as the Euclidean Algorithm is to use a recursion with the base case gcd(p, 0) = p and the relation gcd(p1, p2) = gcd(p2, rem(p1, p2)). The relation comes from the Euclidean division: p1 = q * p2 + r, if g divides p1 and p2 then it divides r and if g divides r and p2 then it divides p1.\n\nFor multivariate polynomials, you may have rem(p1, p2) = p1 hence this will not terminate. To ensure we make progress, we can pick a given variable xi and try to find q1 and q2 such that q2 * p1 = q1 * p2 + r and the degree of r in xi is strictly smaller than the degree of p1 in xi. Note that if g divides p1 and p2 then it divides r but if g divides r and p2 then it might divide q2 and not p1. So what do we do ? Let dj be the degree of pj in xi. Suppose we pick qj to be the coefficient of pj in xi^dj. If g divides q2 then it means that the degree of g in xi is zero. Therefore, if it divides p2 then it also divides the coefficients of p2 in xi^k for k = 0, 1, ..., d2. This means that if we ensure that these are relatively prime then we won't have any issue. So we start by computing a gcd gj of the coefficients in each degree of xi of pj, this is called the content of pj. And then we compute _gcd(p1 / g1, p2 / g2) * gcd(g1, g2) where we can use the recursion _gcd(p1, p2) = _gcd(p2, q2 * p1 - q1 * p2) where q1, q2 are as defined above. This is the GeneralizedEuclideanAlgorithm.\n\n[Knu14] Knuth, D.E., 2014. Art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley Professional. Third edition.\n\n\n\n\n\n","category":"function"},{"location":"division/#Base.lcm","page":"Division","title":"Base.lcm","text":"lcm(m1::AbstractMonomialLike, m2::AbstractMonomialLike)\n\nReturn the smallest monomial m such that both divides(m1, m) and divides(m2, m) are true.\n\njulia> @polyvar x y z;\n\njulia> lcm(x^2*y^7*z^3, x^4*y^5*z^2)\nx^4*y^7*z^3\n\n\n\n\n\n","category":"function"},{"location":"division/#MultivariatePolynomials.AbstractUnivariateGCDAlgorithm","page":"Division","title":"MultivariatePolynomials.AbstractUnivariateGCDAlgorithm","text":"abstract type AbstractUnivariateGCDAlgorithm end\n\nAlgorithm computing the greatest common divisor of univariate polynomials. See GeneralizedEuclideanAlgorithm and SubresultantAlgorithm.\n\n\n\n\n\n","category":"type"},{"location":"division/#MultivariatePolynomials.GeneralizedEuclideanAlgorithm","page":"Division","title":"MultivariatePolynomials.GeneralizedEuclideanAlgorithm","text":"struct GeneralizedEuclideanAlgorithm <: AbstractUnivariateGCDAlgorithm\n    primitive_rem::Bool\n    skip_last::Bool\nend\n\nAlgorithm computing the greatest common divisor of univariate polynomials using the Euclidean algorithm generalized for polynomials with coefficients over a a unique factorization domain, see [Knu14, Algorithm E, p. 426-427].\n\nIf primitive_rem is true, the intermediate remainders produced in the polynomial division are made primitive. If primitive_part is set to false, only the resuting remainder is made primitive (the intermediate remainders of the generalized Euclidean algorithm still need to be made primitive).\n\n[Knu14] Knuth, D.E., 2014. Art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley Professional. Third edition.\n\n\n\n\n\n","category":"type"},{"location":"division/#MultivariatePolynomials.SubresultantAlgorithm","page":"Division","title":"MultivariatePolynomials.SubresultantAlgorithm","text":"mutable struct SubresultantAlgorithm <: AbstractUnivariateGCDAlgorithm\n    skipped_divisions::Int\nend\n\nAlgorithm computing the greatest common divisor of univariate polynomials using the Subresultant algorithm, see [Knu14, Algorithm C, p. 428-429].\n\nThe division by g*h^δ in the algorithm only works if the iteration of [Knu14, Algorithm R, p. 426] is carried out even when the divided polynomial has a zero term. For computational savings, we don't do that so we store in skipped_division the number of skipped divisions so that the division by g*h^δ can be adapted accordingly.\n\nIn [Knu14, Algorithm C, p. 426], it is stated that there should be ``\n\n[Knu14] Knuth, D.E., 2014. Art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley Professional. Third edition.\n\n\n\n\n\n","category":"type"},{"location":"division/","page":"Division","title":"Division","text":"Internal functions of the gcd algorithm:","category":"page"},{"location":"division/#MultivariatePolynomials.isolate_variable","page":"Division","title":"MultivariatePolynomials.isolate_variable","text":"isolate_variable(poly::_APL, var::AbstractVariable, mutability::MA.MutableTrait)\n\nReturns a polynomial with variable var. The other variables of poly are moved as coefficients.\n\nThe output can be mutated without affecting poly if mutability is MA.IsNotMutable.\n\n\n\n\n\n","category":"function"},{"location":"division/#MultivariatePolynomials.primitive_univariate_gcd!","page":"Division","title":"MultivariatePolynomials.primitive_univariate_gcd!","text":"primitive_univariate_gcd!(p::_APL, q::_APL, algo::AbstractUnivariateGCDAlgorithm)\n\nReturns the gcd of primitive polynomials p and q using algorithm algo which is a subtype of AbstractUnivariateGCDAlgorithm. The function might modify p or q.\n\n\n\n\n\n","category":"function"},{"location":"division/#MultivariatePolynomials.univariate_gcd","page":"Division","title":"MultivariatePolynomials.univariate_gcd","text":"univariate_gcd(p1::AbstractPolynomialLike, p2::AbstractPolynomialLike, algo::AbstractUnivariateGCDAlgorithm)\n\nReturn the greatest common divisor of the polynomials p1 and p2 that have at most one variable in common and for which the coefficients are either AbstractFloat or part of a unique factorization domain, e.g., rational numbers, integers or multivariate polynomials. So p1 and p2 should have at most one variable in common but their coefficients can be multivariate polynomials that share arbitrarily many variables.\n\nIf the coefficients are not AbstractFloat, this\n\nseparates p1 and p2 in their content and primitive_part using primitive_part_content; see [Knu14, Algorithm E: E1, p. 426] or [Knu14, Algorithm C: C1, p. 428].\nComputes the gcd of the contents and primitive parts, using primitive_univariate_gcd! for primitive parts.\nReturn the product of these two gcd; see [Knu14, Algorithm E: E4, p. 427] or [Knu14, Algorithm C: C4, p. 429].\n\n[Knu14] Knuth, D.E., 2014. Art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley Professional. Third edition.\n\n\n\n\n\n","category":"function"},{"location":"division/#MultivariatePolynomials.content","page":"Division","title":"MultivariatePolynomials.content","text":"content(poly::AbstractPolynomialLike{T}, algo::AbstractUnivariateGCDAlgorithm, mutability::MA.MutableTrait) where {T}\n\nReturn the content of the polynomial poly over a unique factorization domain S as defined in [Knu14, (3) p. 423]. That is, return the gcd of the coefficients of poly. See also primitive_part_content.\n\nThe output can be mutated without affecting poly if mutability is MA.IsNotMutable.\n\n[Knu14] Knuth, D.E., 2014. Art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley Professional. Third edition.\n\n\n\n\n\n","category":"function"},{"location":"division/#MultivariatePolynomials.primitive_part","page":"Division","title":"MultivariatePolynomials.primitive_part","text":"primitive_part(poly::AbstractPolynomialLike{T}, algo::AbstractUnivariateGCDAlgorithm) where {T}\n\nReturn the primitive part of the polynomial poly over a unique factorization domain S as defined in [Knu14, (3) p. 423]. That is, return the exact division of poly by its content. If the content is also needed, call primitive_part_content instead.\n\n[Knu14] Knuth, D.E., 2014. Art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley Professional. Third edition.\n\n\n\n\n\n","category":"function"},{"location":"division/#MultivariatePolynomials.primitive_part_content","page":"Division","title":"MultivariatePolynomials.primitive_part_content","text":"primitive_part_content(poly::AbstractPolynomialLike{T}, algo::AbstractUnivariateGCDAlgorithm) where {T}\n\nReturn the primitive part and content of the polynomial poly over a unique factorization domain S as defined in [Knu14, (3) p. 423]. This is more efficient to call this function rather than calling primitive_part and content separately since computing the primitive part requires computing the content first and this function avoid computing the content twice.\n\n[Knu14] Knuth, D.E., 2014. Art of computer programming, volume 2: Seminumerical algorithms. Addison-Wesley Professional. Third edition.\n\n\n\n\n\n","category":"function"},{"location":"#MultivariatePolynomials","page":"Introduction","title":"MultivariatePolynomials","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MultivariatePolynomials.jl is an implementation independent library for manipulating multivariate polynomials. It defines abstract types and an API for multivariate monomials, terms, polynomials and gives default implementation for common operations on them using the API.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"On the one hand, This packages allows you to implement algorithms on multivariate polynomials that will be independant on the representation of the polynomial that will be chosen by the user. On the other hand, it allows the user to easily switch between different representations of polynomials to see which one is faster for the algorithm that he is using.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Supported operations are : basic arithmetic, rational polynomials, evaluation/substitution, differentiation and division.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following packages provide representations of multivariate polynomials that implement the interface:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"TypedPolynomials : Commutative polynomials of arbitrary coefficient types\nDynamicPolynomials : Commutative and non-commutative polynomials of arbitrary coefficient types","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The following packages extend the interface and/or implement algorithms using the interface:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"SemialgebraicSets : Sets defined by inequalities and equalities between polynomials and algorithms for solving polynomial systems of equations.\nHomotopyContinuation : Solving systems of polynomials via homotopy continuation.\nMultivariateBases : Standardized API for multivariate polynomial bases.\nMultivariateMoments : Moments of multivariate measures and their scalar product with polynomials.\nPolyJuMP : A JuMP extension for Polynomial Optimization.\nSumOfSquares : Certifying the nonnegativity of polynomials, minimizing/maximizing polynomials and optimization over sum of squares polynomials using Sum of Squares Programming.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"types.md\", \"substitution.md\", \"differentiation.md\", \"division.md\", \"internal.md\"]\nDepth = 3","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Variables","page":"Types","title":"Variables","text":"","category":"section"},{"location":"types/#MultivariatePolynomials.AbstractVariable","page":"Types","title":"MultivariatePolynomials.AbstractVariable","text":"AbstractVariable <: AbstractMonomialLike\n\nAbstract type for a variable.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.variable","page":"Types","title":"MultivariatePolynomials.variable","text":"variable(p::AbstractPolynomialLike)\n\nConverts p to a variable. Throws InexactError if it is not possible.\n\nExamples\n\nCalling variable(x^2 + x - x^2) should return the variable x and calling variable(1.0y) should return the variable y however calling variable(2x) or variable(x + y) should throw InexactError.\n\nNote\n\nThis operation is not type stable for the TypedPolynomials implementation if nvariables(p) > 1 but is type stable for DynamicPolynomials.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.name","page":"Types","title":"MultivariatePolynomials.name","text":"name(v::AbstractVariable)::AbstractString\n\nReturns the name of a variable.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.name_base_indices","page":"Types","title":"MultivariatePolynomials.name_base_indices","text":"name_base_indices(v::AbstractVariable)\n\nReturns the name of the variable (as a String or Symbol) and its indices as a Vector{Int} or tuple of Ints.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.variable_union_type","page":"Types","title":"MultivariatePolynomials.variable_union_type","text":"variable_union_type(p::AbstractPolynomialLike)\n\nReturn the supertype for variables of p. If p is a variable, it should not be the type of p but the supertype of all variables that could be created.\n\nExamples\n\nFor TypedPolynomials, a variable of name x has type Variable{:x} so variable_union_type should return Variable. For DynamicPolynomials, all variables have the same type Variable{C} where C is true for commutative variables and false for non-commutative ones so variable_union_type should return Variable{C}.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.similar_variable","page":"Types","title":"MultivariatePolynomials.similar_variable","text":"similar_variable(p::AbstractPolynomialLike, variable::Type{Val{V}})\n\nCreates a new variable V based upon the the given source polynomial.\n\nsimilar_variable(p::AbstractPolynomialLike, v::Symbol)\n\nCreates a new variable based upon the given source polynomial and the given symbol v. Note that this can lead to type instabilities.\n\nExamples\n\nCalling similar_variable(typedpoly, Val{:x}) on a polynomial created with TypedPolynomials results in TypedPolynomials.Variable{:x}.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.@similar_variable","page":"Types","title":"MultivariatePolynomials.@similar_variable","text":"@similar_variable(p::AbstractPolynomialLike, variable)\n\nCalls similar_variable(p, Val{variable}) and binds the result to a variable with the same name.\n\nExamples\n\nCalling @similar_variable typedpoly x on a polynomial created with TypedPolynomials binds TypedPolynomials.Variable{:x} to the variable x.\n\n\n\n\n\n","category":"macro"},{"location":"types/#Base.conj-Tuple{AbstractVariable}","page":"Types","title":"Base.conj","text":"conj(x::AbstractVariable)\n\nReturn the complex conjugate of a given variable if it was declared as a complex variable; else return the variable unchanged.\n\nSee also isreal, isconj.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.real-Tuple{AbstractVariable}","page":"Types","title":"Base.real","text":"real(x::AbstractVariable)\n\nReturn the real part of a given variable if it was declared as a complex variable; else return the variable unchanged.\n\nSee also imag.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.imag-Tuple{AbstractVariable}","page":"Types","title":"Base.imag","text":"imag(x::AbstractVariable)\n\nReturn the imaginary part of a given variable if it was declared as a complex variable; else return zero.\n\nSee also isreal, isimagpart, real.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.isreal-Tuple{AbstractVariable}","page":"Types","title":"Base.isreal","text":"isreal(x::AbstractVariable)\n\nReturn whether a given variable was declared as a real-valued or complex-valued variable (also their conjugates are complex, but their real and imaginary parts are not). By default, all variables are real-valued.\n\n\n\n\n\n","category":"method"},{"location":"types/#MultivariatePolynomials.isrealpart","page":"Types","title":"MultivariatePolynomials.isrealpart","text":"isrealpart(x::AbstractVariable)\n\nReturn whether the given variable is the real part of a complex-valued variable.\n\nSee also isreal, isimagpart, isconj.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.isimagpart","page":"Types","title":"MultivariatePolynomials.isimagpart","text":"isimagpart(x::AbstractVariable)\n\nReturn whether the given variable is the imaginary part of a complex-valued variable.\n\nSee also isreal, isrealpart, isconj.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.isconj","page":"Types","title":"MultivariatePolynomials.isconj","text":"isconj(x::AbstractVariable)\n\nReturn whether the given variable is obtained by conjugating a user-defined complex-valued variable.\n\nSee also isreal, isrealpart, isimagpart.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.ordinary_variable","page":"Types","title":"MultivariatePolynomials.ordinary_variable","text":"ordinary_variable(x::Union{AbstractVariable, AbstractVector{<:AbstractVariable}})\n\nGiven some (complex-valued) variable that was transformed by conjugation, taking its real part, or taking its imaginary part, return the original variable as it was defined by the user.\n\nSee also conj, real, imag.\n\n\n\n\n\n","category":"function"},{"location":"types/#Monomials","page":"Types","title":"Monomials","text":"","category":"section"},{"location":"types/#MultivariatePolynomials.AbstractMonomialLike","page":"Types","title":"MultivariatePolynomials.AbstractMonomialLike","text":"AbstractMonomialLike\n\nAbstract type for a value that can act like a monomial. For instance, an AbstractVariable is an AbstractMonomialLike since it can act as a monomial of one variable with degree 1.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.AbstractMonomial","page":"Types","title":"MultivariatePolynomials.AbstractMonomial","text":"AbstractMonomial <: AbstractMonomialLike\n\nAbstract type for a monomial, i.e. a product of variables elevated to a nonnegative integer power.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.monomial_type","page":"Types","title":"MultivariatePolynomials.monomial_type","text":"monomial_type(p::AbstractPolynomialLike)\n\nReturn the type of the monomials of p.\n\nmonomial_type(::Type{PT}) where PT<:AbstractPolynomialLike\n\nReturns the type of the monomials of a polynomial of type PT.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.variables","page":"Types","title":"MultivariatePolynomials.variables","text":"variables(p::AbstractPolynomialLike)\n\nReturns the tuple of the variables of p in decreasing order. It could contain variables of zero degree, see the example section.\n\nExamples\n\nCalling variables(x^2*y) should return (x, y) and calling variables(x) should return (x,). Note that the variables of m does not necessarily have nonzero degree. For instance, variables([x^2*y, y*z][1]) is usually (x, y, z) since the two monomials have been promoted to a common type.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.effective_variables","page":"Types","title":"MultivariatePolynomials.effective_variables","text":"effective_variables(p::AbstractPolynomialLike)\n\nReturn a vector of eltype variable_union_type(p) (see variable_union_type), containing all the variables that has nonzero degree in at least one term. That is, return all the variables v such that maxdegree(p, v) is not zero. The returned vector is sorted in decreasing order.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.nvariables","page":"Types","title":"MultivariatePolynomials.nvariables","text":"nvariables(p::AbstractPolynomialLike)\n\nReturns the number of variables in p, i.e. length(variables(p)). It could be more than the number of variables with nonzero degree (see the Examples section of variables).\n\nExamples\n\nCalling nvariables(x^2*y) should return at least 2 and calling nvariables(x) should return at least 1.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.exponents","page":"Types","title":"MultivariatePolynomials.exponents","text":"exponents(t::AbstractTermLike)\n\nReturns the exponent of the variables in the monomial of the term t.\n\nExamples\n\nCalling exponents(x^2*y) should return (2, 1).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.degree","page":"Types","title":"MultivariatePolynomials.degree","text":"degree(t::AbstractTermLike)\n\nReturns the total degree of the monomial of the term t, i.e. sum(exponents(t)).\n\ndegree(t::AbstractTermLike, v::AbstractVariable)\n\nReturns the exponent of the variable v in the monomial of the term t.\n\nExamples\n\nCalling degree(x^2*y) should return 3 which is 2 + 1. Calling degree(x^2*y, x) should return 2 and calling degree(x^2*y, y) should return 1.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.isconstant","page":"Types","title":"MultivariatePolynomials.isconstant","text":"isconstant(t::AbstractTermLike)\n\nReturns whether the monomial of t is constant.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.powers","page":"Types","title":"MultivariatePolynomials.powers","text":"powers(t::AbstractTermLike)\n\nReturns an iterator over the powers of the monomial of t.\n\nExamples\n\nCalling powers(3x^4*y) should return ((x, 4), (y, 1)).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.constant_monomial","page":"Types","title":"MultivariatePolynomials.constant_monomial","text":"constant_monomial(p::AbstractPolynomialLike)\n\nReturns a constant monomial of the monomial type of p with the same variables as p.\n\nconstant_monomial(::Type{PT}) where {PT<:AbstractPolynomialLike}\n\nReturns a constant monomial of the monomial type of a polynomial of type PT.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.map_exponents","page":"Types","title":"MultivariatePolynomials.map_exponents","text":"map_exponents(f, m1::AbstractMonomialLike, m2::AbstractMonomialLike)\n\nIf m_1 = prod x^alpha_i and m_2 = prod x^beta_i then it returns the monomial m = prod x^f(alpha_i beta_i).\n\nExamples\n\nThe multiplication m1 * m2 is equivalent to map_exponents(+, m1, m2), the unsafe division div_multiple(m1, m2) is equivalent to map_exponents(-, m1, m2), gcd(m1, m2) is equivalent to map_exponents(min, m1, m2), lcm(m1, m2) is equivalent to map_exponents(max, m1, m2).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.multiplication_preserves_monomial_order","page":"Types","title":"MultivariatePolynomials.multiplication_preserves_monomial_order","text":"multiplication_preserves_monomial_order(P::Type{<:AbstractPolynomialLike})\n\nReturns a Bool indicating whether the order is preserved in the multiplication of monomials of type monomial_type(P). That is, if a < b then a * c < b * c for any monomial c. This returns true by default. This is used by Polynomial so a monomial type for which the multiplication does not preserve the monomial order can still be used with Polynomial if it implements a method for this function that returns false.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.promote_variables","page":"Types","title":"MultivariatePolynomials.promote_variables","text":"promote_variables(p::AbstractPolynomialLike, q::AbstractPolynomialLike)\n\nReturn two polynomials over the same variables.\n\n\n\n\n\n","category":"function"},{"location":"types/#Ordering","page":"Types","title":"Ordering","text":"","category":"section"},{"location":"types/#MultivariatePolynomials.AbstractMonomialOrdering","page":"Types","title":"MultivariatePolynomials.AbstractMonomialOrdering","text":"abstract type AbstractMonomialOrdering end\n\nAbstract type for monomial ordering as defined in [CLO13, Definition 2.2.1, p. 55]\n\nGiven an ordering ordering::AbstractMonomialOrdering and vector of exponents e1 and e2, cmp(ordering, e1, e2) returns a negative number if e1 is before e2 in the ordering, a positive number if e2 is before e1 and 0 if they are equal. For convenience, ordering(e1, e2) returns a Bool indicating whether cmp(ordering, e1, e2) is negative.\n\n[CLO13] Cox, D., Little, J., & OShea, D. Ideals, varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra. Springer Science & Business Media, 2013.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.ordering","page":"Types","title":"MultivariatePolynomials.ordering","text":"ordering(p::AbstractPolynomialLike)::Type{<:AbstractMonomialOrdering}\n\nReturns the AbstractMonomialOrdering type to be used to compare exponent vectors for the monomials of p.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.compare","page":"Types","title":"MultivariatePolynomials.compare","text":"compare(a, b, order::Type{<:AbstractMonomialOrdering})\n\nReturns a negative number if a < b, a positive number if a > b and zero if a == b. The comparison is done according to order.\n\nWarning This is deprecated, use cmp(order(), a, b) instead.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.LexOrder","page":"Types","title":"MultivariatePolynomials.LexOrder","text":"struct LexOrder <: AbstractMonomialOrdering end\n\nLexicographic (Lex for short) Order often abbreviated as lex order as defined in [CLO13, Definition 2.2.3, p. 56]\n\nThe Graded version is often abbreviated as grlex order and is defined in [CLO13, Definition 2.2.5, p. 58]\n\n[CLO13] Cox, D., Little, J., & OShea, D. Ideals, varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra. Springer Science & Business Media, 2013.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.InverseLexOrder","page":"Types","title":"MultivariatePolynomials.InverseLexOrder","text":"struct InverseLexOrder <: AbstractMonomialOrdering end\n\nInverse Lex Order defined in [CLO13, Exercise 2.2.6, p. 61] where it is abbreviated as invlex. It corresponds to LexOrder but with the variables in reverse order.\n\nThe Graded version can be abbreviated as grinvlex order. It is defined in [BDD13, Definition 2.1] where it is called Graded xel order.\n\n[CLO13] Cox, D., Little, J., & OShea, D. Ideals, varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra. Springer Science & Business Media, 2013. [BDD13] Batselier, K., Dreesen, P., & De Moor, B. The geometry of multivariate polynomial division and elimination. SIAM Journal on Matrix Analysis and Applications, 34(1), 102-125, 2013.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.Graded","page":"Types","title":"MultivariatePolynomials.Graded","text":"struct Graded{O<:AbstractMonomialOrdering} <: AbstractMonomialOrdering\n    same_degree_ordering::O\nend\n\nMonomial ordering defined by:\n\ndegree(a) == degree(b) then the ordering is determined by same_degree_ordering,\notherwise, it is the ordering between the integers degree(a) and degree(b).\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.Reverse","page":"Types","title":"MultivariatePolynomials.Reverse","text":"struct Reverse{O<:AbstractMonomialOrdering} <: AbstractMonomialOrdering\n    reverse_order::O\nend\n\nMonomial ordering defined by cmp(o::Reverse, a, b) where {O} = cmp(o.reverse_order, b, a).\n\nReverse Lex Order defined in [CLO13, Exercise 2.2.9, p. 61] where it is abbreviated as rinvlex. can be obtained as Reverse{InverseLexOrder}.\n\nThe Graded Reverse Lex Order often abbreviated as grevlex order defined in [CLO13, Definition 2.2.6, p. 58] can be obtained as Graded{Reverse{InverseLexOrder}}.\n\n[CLO13] Cox, D., Little, J., & OShea, D. Ideals, varieties, and algorithms: an introduction to computational algebraic geometry and commutative algebra. Springer Science & Business Media, 2013.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.ExponentsIterator","page":"Types","title":"MultivariatePolynomials.ExponentsIterator","text":"struct ExponentsIterator{M}(\n    object;\n    mindegree::Int = 0,\n    maxdegree::Union{Nothing,Int} = nothing,\n    inline::Bool = false,\n)\n\nAn iterator for generating monomial exponents for monomial ordering M. The type of the vector of exponents is the type of object and is length (i.e., the number of variables) is length(object).\n\nNote that object does not have to be zero, it just needs to implement copy and setindex! methods (except for Tuple which we handle with a special case).\n\nSee also monomials.\n\nExamples\n\nThe following example shows how to generate all exponents of monomials of 2 variables up to degree 2.\n\njulia> collect(ExponentsIterator{Graded{LexOrder}}((0, 0), maxdegree = 2))\n6-element Vector{Tuple{Int64, Int64}}:\n (0, 0)\n (0, 1)\n (1, 0)\n (0, 2)\n (1, 1)\n (2, 0)\n\nNote that you can easily generate the tuple of exponents of arbitrary length using ntuple as follows:\n\njulia> collect(ExponentsIterator{Graded{LexOrder}}(ntuple(zero, 3), mindegree = 2, maxdegree = 2))\n6-element Vector{Tuple{Int64, Int64, Int64}}:\n (0, 0, 2)\n (0, 1, 1)\n (0, 2, 0)\n (1, 0, 1)\n (1, 1, 0)\n (2, 0, 0)\n\nYou can also change the monomial ordering and use Vector instead of Tuple as follows:\n\njulia> collect(ExponentsIterator{LexOrder}(zeros(Int, 2), mindegree = 2, maxdegree = 3))\n7-element Vector{Vector{Int64}}:\n [0, 2]\n [0, 3]\n [1, 1]\n [1, 2]\n [2, 0]\n [2, 1]\n [3, 0]\n\n\n\n\n\n","category":"type"},{"location":"types/#Terms","page":"Types","title":"Terms","text":"","category":"section"},{"location":"types/#MultivariatePolynomials.AbstractTermLike","page":"Types","title":"MultivariatePolynomials.AbstractTermLike","text":"AbstractTermLike{T}\n\nAbstract type for a value that can act like a term. For instance, an AbstractMonomial is an AbstractTermLike{Int} since it can act as a term with coefficient 1.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.AbstractTerm","page":"Types","title":"MultivariatePolynomials.AbstractTerm","text":"AbstractTerm{T} <: AbstractTermLike{T}\n\nAbstract type for a term of coefficient type T, i.e. the product between a value of type T and a monomial.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.Term","page":"Types","title":"MultivariatePolynomials.Term","text":"struct Term{CoeffType,M<:AbstractMonomial} <: AbstractTerm{CoeffType}\n    coefficient::CoeffType\n    monomial::M\nend\n\nA representation of the multiplication between a coefficient and a monomial.\n\nnote: Note\nThe coefficient does not need to be a Number. It can be for instance a multivariate polynomial. When computing a multivariate gcd, it is actually reformulated as a univariate gcd in one of the variable with coefficients being multivariate polynomials in the other variables. To create such a term, use term instead of *. For instance, if p is a polynomial and m is a monomial, p * m will multiply each term of p with m but term(p, m) will create a term with p as coefficient and m as monomial.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.term","page":"Types","title":"MultivariatePolynomials.term","text":"term(coef, mono::AbstractMonomialLike)\n\nReturns a term with coefficient coef and monomial mono. There are two key difference between this and coef * mono:\n\nterm(coef, mono) does not copy coef and mono so modifying this term with MutableArithmetics may modifying the input of this function. To avoid this, call term(MA.copy_if_mutable(coef), MA.copy_if_mutable(mono)) where MA = MutableArithmetics.\nSuppose that coef = (x + 1) and mono = x^2, coef * mono gives the polynomial with integer coefficients x^3 + x^2 which term(x + 1, x^2) gives a term with polynomial coefficient x + 1.\nterm(p::AbstractPolynomialLike)\n\nConverts the polynomial p to a term. When applied on a polynomial, it throws an InexactError if it has more than one term. When applied to a term, it is the identity and does not copy it. When applied to a monomial, it create a term of type AbstractTerm{Int}.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.term_type","page":"Types","title":"MultivariatePolynomials.term_type","text":"term_type(p::AbstractPolynomialLike)\n\nReturns the type of the terms of p.\n\nterm_type(::Type{PT}) where PT<:AbstractPolynomialLike\n\nReturns the type of the terms of a polynomial of type PT.\n\nterm_type(p::AbstractPolynomialLike, ::Type{T}) where T\n\nReturns the type of the terms of p but with coefficient type T.\n\nterm_type(::Type{PT}, ::Type{T}) where {PT<:AbstractPolynomialLike, T}\n\nReturns the type of the terms of a polynomial of type PT but with coefficient type T.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.coefficient","page":"Types","title":"MultivariatePolynomials.coefficient","text":"coefficient(t::AbstractTermLike)\n\nReturns the coefficient of the term t.\n\ncoefficient(p::AbstractPolynomialLike, m::AbstractMonomialLike)\n\nReturns the coefficient of the monomial m in p.\n\nExamples\n\nCalling coefficient on 4x^2y should return 4. Calling coefficient(2x + 4y^2 + 3, y^2) should return 4. Calling coefficient(2x + 4y^2 + 3, x^2) should return 0.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.coefficient_type","page":"Types","title":"MultivariatePolynomials.coefficient_type","text":"coefficient_type(p::AbstractPolynomialLike)\n\nReturns the coefficient type of p.\n\ncoefficient_type(::Type{PT}) where PT\n\nReturns the coefficient type of a polynomial of type PT.\n\nExamples\n\nCalling coefficient_type on (45)x^2y should return Rational{Int}, calling coefficient_type on 10x^2y + 20x should return Float64 and calling coefficient_type on xy should return Int.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.monomial","page":"Types","title":"MultivariatePolynomials.monomial","text":"monomial(t::AbstractTermLike)\n\nReturns the monomial of the term t.\n\nExamples\n\nCalling monomial on 4x^2y should return x^2y.\n\nmonomial(variables, exponents)\n\nReturns the monomial corresponding to prod(variables .^ exponents)\n\nExamples\n\nIn order to create x^2 * y,\n\nwith DynamicPolynomials, use monomial([x, y], [2, 1]),\nwith TypedPolynomials, use monomial((x, y), (2, 1)).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.constant_term","page":"Types","title":"MultivariatePolynomials.constant_term","text":"constant_term(α, p::AbstractPolynomialLike)\n\nCreates a constant term with coefficient α and the same variables as p.\n\nconstant_term(α, ::Type{PT} where {PT<:AbstractPolynomialLike}\n\nCreates a constant term of the term type of a polynomial of type PT.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.zero_term","page":"Types","title":"MultivariatePolynomials.zero_term","text":"zero_term(p::AbstractPolynomialLike{T}) where T\n\nEquivalent to constant_term(zero(T), p).\n\nzero_term(α, ::Type{PT} where {T, PT<:AbstractPolynomialLike{T}}\n\nEquivalent to constant_term(zero(T), PT).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.degree_complex","page":"Types","title":"MultivariatePolynomials.degree_complex","text":"degree_complex(t::AbstractTermLike)\n\nReturn the total complex degree of the monomial of the term t, i.e., the maximum of the total degree of the declared variables in t and the total degree of the conjugate variables in t. To be well-defined, the monomial must not contain real parts or imaginary parts of variables. If x₁ and x₂ are real-valued variables and z₁ and z₂ are complex-valued,\n\ndegree_complex(x₁^2 * x₂^3) = 5\ndegree_complex(z₁^3 * conj(z₁)^4) = max(3, 4) = 4 and degree_complex(z₁^4 * conj(z₁)^3) = max(4, 3) = 4\ndegree_complex(z₁^3 * z₂ * conj(z₁)^2 * conj(z₂)^4) = max(4, 6) = 6 and degree_complex(z₁^4 * z₂ * conj(z₁) * conj(z₂)^3) = max(5, 4) = 5\ndegree_complex(x₁^2 * x₂^3 * z₁^3 * z₂ * conj(z₁)^2 * conj(z₂)^4) = 5 + max(4, 6) = 11\n\n\n\n\n\ndegree_complex(t::AbstractTermLike, v::AbstractVariable)\n\nReturns the exponent of the variable v or its conjugate in the monomial of the term t, whatever is larger.\n\nSee also isconj.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.halfdegree","page":"Types","title":"MultivariatePolynomials.halfdegree","text":"halfdegree(t::AbstractTermLike)\n\nReturn the equivalent of ceil(degree(t)/2)for real-valued terms ordegree_complex(t)for terms with only complex variables; however, respect any mixing between complex and real-valued variables. To be well-defined, the monomial must not contain real parts or imaginary parts of variables. Ifx₁andx₂are real-valued variables andz₁andz₂` are complex-valued,\n\nhalfdegree(x₁^2 * x₂^3) = ⌈5/2⌉ = 3\nhalfdegree(z₁^3 * conj(z₁)^4) = max(3, 4) = 4 and halfdegree(z₁^4 * conj(z₁)^3) = max(4, 3) = 4\nhalfdegree(z₁^3 * z₂ * conj(z₁)^2 * conj(z₂)^4) = max(4, 6) = 6 and halfdegree(z₁^4 * z₂ * conj(z₁) * conj(z₂)^3) = max(5, 4) = 5\nhalfdegree(x₁^2 * x₂^3 * z₁^3 * z₂ * conj(z₁)^2 * conj(z₂)^4) = ⌈5/2⌉ + max(4, 6) = 9\n\n\n\n\n\n","category":"function"},{"location":"types/#Polynomials","page":"Types","title":"Polynomials","text":"","category":"section"},{"location":"types/#MultivariatePolynomials.AbstractPolynomialLike","page":"Types","title":"MultivariatePolynomials.AbstractPolynomialLike","text":"AbstractPolynomialLike{T}\n\nAbstract type for a value that can act like a polynomial. For instance, an AbstractTerm{T} is an AbstractPolynomialLike{T} since it can act as a polynomial of only one term.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.AbstractPolynomial","page":"Types","title":"MultivariatePolynomials.AbstractPolynomial","text":"AbstractPolynomial{T} <: AbstractPolynomialLike{T}\n\nAbstract type for a polynomial of coefficient type T, i.e. a sum of AbstractTerm{T}s.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.Polynomial","page":"Types","title":"MultivariatePolynomials.Polynomial","text":"struct Polynomial{CoeffType,T<:AbstractTerm{CoeffType},V<:AbstractVector{T}} <: AbstractPolynomial{CoeffType}\n    terms::V\nend\n\nRepresentation of a multivariate polynomial as a vector of nonzero terms sorted in ascending monomial order.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.polynomial","page":"Types","title":"MultivariatePolynomials.polynomial","text":"polynomial(p::AbstractPolynomialLike)\n\nConverts p to a value with polynomial type.\n\npolynomial(p::AbstractPolynomialLike, ::Type{T}) where T\n\nConverts p to a value with polynomial type with coefficient type T.\n\npolynomial(a::AbstractVector, mv::AbstractVector{<:AbstractMonomialLike})\n\nCreates a polynomial equal to dot(a, mv).\n\npolynomial(terms::AbstractVector{<:AbstractTerm}, s::ListState=MessyState())\n\nCreates a polynomial equal to sum(terms) where terms are guaranteed to be in state s.\n\npolynomial(f::Function, mv::AbstractVector{<:AbstractMonomialLike})\n\nCreates a polynomial equal to sum(f(i) * mv[i] for i in 1:length(mv)).\n\nExamples\n\nCalling polynomial([2, 4, 1], [x, x^2*y, x*y]) should return 4x^2y + xy + 2x.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.polynomial_type","page":"Types","title":"MultivariatePolynomials.polynomial_type","text":"polynomial_type(p::AbstractPolynomialLike)\n\nReturns the type that p would have if it was converted into a polynomial.\n\npolynomial_type(::Type{PT}) where PT<:AbstractPolynomialLike\n\nReturns the same as polynomial_type(::PT).\n\npolynomial_type(p::AbstractPolynomialLike, ::Type{T}) where T\n\nReturns the type that p would have if it was converted into a polynomial of coefficient type T.\n\npolynomial_type(::Type{PT}, ::Type{T}) where {PT<:AbstractPolynomialLike, T}\n\nReturns the same as polynomial_type(::PT, ::Type{T}).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.terms","page":"Types","title":"MultivariatePolynomials.terms","text":"terms(p::AbstractPolynomialLike)\n\nReturns an iterator over the nonzero terms of the polynomial p sorted in the decreasing monomial order.\n\nExamples\n\nCalling terms on 4x^2y + xy + 2x should return an iterator of 4x^2y xy 2x.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.nterms","page":"Types","title":"MultivariatePolynomials.nterms","text":"nterms(p::AbstractPolynomialLike)\n\nReturns the number of nonzero terms in p, i.e. length(terms(p)).\n\nExamples\n\nCalling nterms on 4x^2y + xy + 2x should return 3.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.coefficients","page":"Types","title":"MultivariatePolynomials.coefficients","text":"coefficients(p::AbstractPolynomialLike)\n\nReturns an iterator over the coefficients of p of the nonzero terms of the polynomial sorted in the decreasing monomial order.\n\ncoefficients(p::AbstractPolynomialLike, X::AbstractVector)\n\nReturns an iterator over the coefficients of the monomials of X in p where X is a monomial vector not necessarily sorted but with no duplicate entry.\n\nExamples\n\nCalling coefficients on 4x^2y + xy + 2x should return an iterator of 4 1 2. Calling coefficients(4x^2*y + x*y + 2x + 3, [x, 1, x*y, y]) should return an iterator of 2 3 1 0.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.coefficient-Tuple{AbstractPolynomialLike, AbstractMonomialLike, Any}","page":"Types","title":"MultivariatePolynomials.coefficient","text":"coefficient(p::AbstractPolynomialLike, m::AbstractMonomialLike, vars)::AbstractPolynomialLike\n\nReturns the coefficient of the monomial m of the polynomial p considered as a polynomial in variables vars.\n\nExample\n\nCalling coefficient((a+b)x^2+2x+y*x^2, x^2, [x,y]) should return a+b. Calling coefficient((a+b)x^2+2x+y*x^2, x^2, [x]) should return a+b+y.\n\n\n\n\n\n","category":"method"},{"location":"types/#MultivariatePolynomials.monomials","page":"Types","title":"MultivariatePolynomials.monomials","text":"monomials(p::AbstractPolynomialLike)\n\nReturns an iterator over the monomials of p of the nonzero terms of the polynomial sorted in the decreasing order.\n\nmonomials(vars::Union{Vector{<:AbstractVariable},Tuple}, degs::AbstractVector{Int}, filter::Function = m -> true)\n\nBuilds the vector of all the monomial_vector m with variables vars such that the degree degree(m) is in degs and filter(m) is true.\n\nSee also ExponentsIterator.\n\nExamples\n\nCalling monomials on 4x^2y + xy + 2x should return an iterator of x^2y xy x.\n\nCalling monomials((x, y), [1, 3], m -> degree(m, y) != 1) should return [x^3, x*y^2, y^3, x] where x^2*y and y have been excluded by the filter.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.mindegree","page":"Types","title":"MultivariatePolynomials.mindegree","text":"mindegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractPolynomialLike}})\n\nReturns the minimal total degree of the monomials of p, i.e. minimum(degree, terms(p)).\n\nmindegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractPolynomialLike}}, v::AbstractVariable)\n\nReturns the minimal degree of the monomials of p in the variable v, i.e. minimum(degree.(terms(p), v)).\n\nExamples\n\nCalling mindegree on on 4x^2y + xy + 2x should return 1, mindegree(4x^2y + xy + 2x, x) should return 1 and  mindegree(4x^2y + xy + 2x, y) should return 0.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.maxdegree","page":"Types","title":"MultivariatePolynomials.maxdegree","text":"maxdegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}})\n\nReturns the maximal total degree of the monomials of p, i.e. maximum(degree, terms(p)).\n\nmaxdegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}}, v::AbstractVariable)\n\nReturns the maximal degree of the monomials of p in the variable v, i.e. maximum(degree.(terms(p), v)).\n\nExamples\n\nCalling maxdegree on 4x^2y + xy + 2x should return 3, maxdegree(4x^2y + xy + 2x, x) should return 2 and  maxdegree(4x^2y + xy + 2x, y) should return 1.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.extdegree","page":"Types","title":"MultivariatePolynomials.extdegree","text":"extdegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractPolynomialLike}})\n\nReturns the extremal total degrees of the monomials of p, i.e. (mindegree(p), maxdegree(p)).\n\nextdegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractPolynomialLike}}, v::AbstractVariable)\n\nReturns the extremal degrees of the monomials of p in the variable v, i.e. (mindegree(p, v), maxdegree(p, v)).\n\nExamples\n\nCalling extdegree on 4x^2y + xy + 2x should return (1, 3), extdegree(4x^2y + xy + 2x, x) should return (1, 2) and  maxdegree(4x^2y + xy + 2x, y) should return (0, 1).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.leading_term","page":"Types","title":"MultivariatePolynomials.leading_term","text":"leading_term(p::AbstractPolynomialLike)\n\nReturns the leading term, i.e. last(terms(p)).\n\nExamples\n\nCalling leading_term on 4x^2y + xy + 2x should return 4x^2y.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.leading_coefficient","page":"Types","title":"MultivariatePolynomials.leading_coefficient","text":"leading_coefficient(p::AbstractPolynomialLike)\n\nReturns the coefficient of the leading term of p, i.e. coefficient(leading_term(p)).\n\nExamples\n\nCalling leading_coefficient on 4x^2y + xy + 2x should return 4 and calling it on 0 should return 0.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.leading_monomial","page":"Types","title":"MultivariatePolynomials.leading_monomial","text":"leading_monomial(p::AbstractPolynomialLike)\n\nReturns the monomial of the leading term of p, i.e. monomial(leading_term(p)) or last(monomials(p)).\n\nExamples\n\nCalling leading_monomial on 4x^2y + xy + 2x should return x^2y.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.deg_num_leading_terms","page":"Types","title":"MultivariatePolynomials.deg_num_leading_terms","text":"deg_num_leading_terms(p::AbstractPolynomialLike, var)\n\nReturn deg, num where deg = maxdegree(p, var) and num is the number of terms t such that degree(t, var) == deg.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.remove_leading_term","page":"Types","title":"MultivariatePolynomials.remove_leading_term","text":"remove_leading_term(p::AbstractPolynomialLike)\n\nReturns a polynomial with the leading term removed in the polynomial p.\n\nExamples\n\nCalling remove_leading_term on 4x^2y + xy + 2x should return xy + 2x.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.remove_monomials","page":"Types","title":"MultivariatePolynomials.remove_monomials","text":"Returns a polynomial with the terms having their monomial in the monomial vector mv removed in the polynomial p.\n\nExamples\n\nCalling remove_monomials(4x^2*y + x*y + 2x, [x*y]) should return 4x^2*y + 2x.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.filter_terms","page":"Types","title":"MultivariatePolynomials.filter_terms","text":"function filter_terms(f::Function, p::AbstractPolynomialLike)\n\nFilter the polynomial p by only keep the terms t such that f(p) is true.\n\nSee also OfDegree.\n\nExamples\n\njulia> p = 1 - 2x + x * y - 3y^2 + x^2 * y\n1 - 2x - 3y² + xy + x²y\n\njulia> filter_terms(OfDegree(2), p)\n-3y² + xy\n\njulia> filter_terms(!OfDegree(2), p)\n1 - 2x + x²y\n\njulia> filter_terms(!OfDegree(0:2), p)\nx²y\n\njulia> filter_terms(iseven ∘ coefficient, p)\n-2x\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.OfDegree","page":"Types","title":"MultivariatePolynomials.OfDegree","text":"struct OfDegree{D} <: Function\n    degree::D\nend\n\nA function d::OfDegree is such that d(t) returns degree(t) == d.degree. Note that !d creates the negation. See also filter_terms.\n\n\n\n\n\n","category":"type"},{"location":"types/#MultivariatePolynomials.monic","page":"Types","title":"MultivariatePolynomials.monic","text":"monic(p::AbstractPolynomialLike)\n\nReturns p / leading_coefficient(p) where the leading coefficient of the returned polynomials is made sure to be exactly one to avoid rounding error.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.map_coefficients","page":"Types","title":"MultivariatePolynomials.map_coefficients","text":"map_coefficients(f::Function, p::AbstractPolynomialLike, nonzero = false)\n\nReturns a polynomial with the same monomials as p but each coefficient α is replaced by f(α). The function may return zero in which case the term is dropped. If the function is known to never return zero for a nonzero input, nonzero can be set to true to get a small speedup.\n\nSee also map_coefficients! and map_coefficients_to!.\n\nExamples\n\nCalling map_coefficients(α -> mod(3α, 6), 2x*y + 3x + 1) should return 3x + 3.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.map_coefficients!","page":"Types","title":"MultivariatePolynomials.map_coefficients!","text":"map_coefficients!(f::Function, p::AbstractPolynomialLike, nonzero = false)\n\nMutate p by replacing each coefficient α by f(α). The function may return zero in which case the term is dropped. If the function is known to never return zero for a nonzero input, nonzero can be set to true to get a small speedup. The function returns p, which is identically equal to the second argument.\n\nSee also map_coefficients and map_coefficients_to!.\n\nExamples\n\nLet p = 2x*y + 3x + 1, after map_coefficients!(α -> mod(3α, 6), p), p is equal to 3x + 3.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.map_coefficients_to!","page":"Types","title":"MultivariatePolynomials.map_coefficients_to!","text":"map_coefficients_to!(output::AbstractPolynomialLike, f::Function, p::AbstractPolynomialLike, nonzero = false)\n\nMutate output by replacing each coefficient α of p by f(α). The function may return zero in which case the term is dropped. If the function is known to never returns zero for a nonzero input, nonzero can be set to true to get a small speedup. The function returns output, which is identically equal to the first argument.\n\nSee also map_coefficients! and map_coefficients.\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.conj-Tuple{AbstractPolynomialLike}","page":"Types","title":"Base.conj","text":"conj(x::AbstractPolynomialLike)\n\nReturn the complex conjugate of x by applying conjugation to all coefficients and variables.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.real-Tuple{AbstractPolynomialLike}","page":"Types","title":"Base.real","text":"real(x::AbstractPolynomialLike)\n\nReturn the real part of x by applying real to all coefficients and variables; for this purpose, every complex-valued variable is decomposed into its real- and imaginary parts.\n\nSee also imag.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.imag-Tuple{AbstractPolynomialLike}","page":"Types","title":"Base.imag","text":"imag(x::AbstractPolynomialLike)\n\nReturn the imaginary part of x by applying imag to all coefficients and variables; for this purpose, every complex-valued variable is decomposed into its real- and imaginary parts.\n\nSee also real.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.isreal-Tuple{AbstractPolynomialLike}","page":"Types","title":"Base.isreal","text":"isreal(p::AbstractPolynomialLike)\n\nReturns true if and only if no single variable in p was declared as a complex variable (in the sense that isreal applied on them would be true) and no coefficient is complex-valued.\n\n\n\n\n\n","category":"method"},{"location":"types/#MultivariatePolynomials.mindegree_complex","page":"Types","title":"MultivariatePolynomials.mindegree_complex","text":"mindegree_complex(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}})\n\nReturn the minimal total complex degree of the monomials of p, i.e., minimum(degree_complex, terms(p)).\n\nmindegree_complex(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}}, v::AbstractVariable)\n\nReturn the minimal complex degree of the monomials of p in the variable v, i.e., minimum(degree_complex.(terms(p), v)).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.minhalfdegree","page":"Types","title":"MultivariatePolynomials.minhalfdegree","text":"minhalfdegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}})\n\nReturn the minmal half degree of the monomials of p, i.e., minimum(halfdegree, terms(p))\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.maxdegree_complex","page":"Types","title":"MultivariatePolynomials.maxdegree_complex","text":"maxdegree_complex(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}})\n\nReturn the maximal total complex degree of the monomials of p, i.e., maximum(degree_complex, terms(p)).\n\nmaxdegree_complex(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}}, v::AbstractVariable)\n\nReturn the maximal complex degree of the monomials of p in the variable v, i.e., maximum(degree_complex.(terms(p), v)).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.maxhalfdegree","page":"Types","title":"MultivariatePolynomials.maxhalfdegree","text":"maxhalfdegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}})\n\nReturn the maximal half degree of the monomials of p, i.e., maximum(halfdegree, terms(p))\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.extdegree_complex","page":"Types","title":"MultivariatePolynomials.extdegree_complex","text":"extdegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}})\n\nReturns the extremal total complex degrees of the monomials of p, i.e., (mindegree_complex(p), maxdegree_complex(p)).\n\nextdegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}}, v::AbstractVariable)\n\nReturns the extremal complex degrees of the monomials of p in the variable v, i.e., (mindegree_complex(p, v), maxdegree_complex(p, v)).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.exthalfdegree","page":"Types","title":"MultivariatePolynomials.exthalfdegree","text":"exthalfdegree(p::Union{AbstractPolynomialLike, AbstractVector{<:AbstractTermLike}})\n\nReturn the extremal half degree of the monomials of p, i.e., (minhalfdegree(p), maxhalfdegree(p))\n\n\n\n\n\n","category":"function"},{"location":"types/#Rational-Polynomial-Function","page":"Types","title":"Rational Polynomial Function","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"A rational polynomial function can be constructed with the / operator. Common operations such as +, -, *, - have been implemented between rational functions. The numerator and denominator polynomials can be retrieved by the numerator and denominator functions.","category":"page"},{"location":"types/#Monomial-Vectors","page":"Types","title":"Monomial Vectors","text":"","category":"section"},{"location":"types/#MultivariatePolynomials.monomial_vector","page":"Types","title":"MultivariatePolynomials.monomial_vector","text":"monomial_vector(X::AbstractVector{MT}) where {MT<:AbstractMonomialLike}\n\nReturns the vector of monomials X in increasing order and without any duplicates.\n\nExamples\n\nCalling monomial_vector on xy x xy x^2y x should return x^2y xy x.\n\n\n\n\n\nmonomial_vector(a, X::AbstractVector{MT}) where {MT<:AbstractMonomialLike}\n\nReturns b, Y where Y is the vector of monomials of X in increasing order and without any duplicates and b is the vector of corresponding coefficients in a, where coefficients of duplicate entries are summed together.\n\nExamples\n\nCalling monomial_vector on 2 1 4 3 -1 xy x xy x^2y x should return 3 6 0 x^2y xy x.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.monomial_vector_type","page":"Types","title":"MultivariatePolynomials.monomial_vector_type","text":"monomial_vector_type(X::AbstractVector{MT}) where {MT<:AbstractMonomialLike}\n\nReturns the return type of monomial_vector.\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.empty_monomial_vector","page":"Types","title":"MultivariatePolynomials.empty_monomial_vector","text":"empty_monomial_vector(p::AbstractPolynomialLike)\n\nReturns an empty collection of the type of monomials(p).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.sort_monomial_vector","page":"Types","title":"MultivariatePolynomials.sort_monomial_vector","text":"sort_monomial_vector(X::AbstractVector{MT}) where {MT<:AbstractMonomialLike}\n\nReturns σ, the orders in which one must take the monomials in X to make them sorted and without any duplicate and the sorted vector of monomials, i.e. it returns (σ, X[σ]).\n\nExamples\n\nCalling sort_monomial_vector on xy x xy x^2y x should return (4 1 2 x^2y xy x).\n\n\n\n\n\n","category":"function"},{"location":"types/#MultivariatePolynomials.merge_monomial_vectors","page":"Types","title":"MultivariatePolynomials.merge_monomial_vectors","text":"merge_monomial_vectors{MT<:AbstractMonomialLike, MVT<:AbstractVector{MT}}(X::AbstractVector{MVT}}\n\nReturns the vector of monomials in the entries of X in increasing order and without any duplicates, i.e. monomial_vector(vcat(X...))\n\nExamples\n\nCalling merge_monomial_vectors on xy x xy x^2y x should return x^2y xy x.\n\n\n\n\n\n","category":"function"},{"location":"types/#Base.conj-Tuple{AbstractVector{<:AbstractMonomial}}","page":"Types","title":"Base.conj","text":"conj(x::AbstractVector{<:AbstractMonomial})\n\nReturn the complex conjugate of x by applying conjugation to monomials.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.real-Tuple{AbstractVector{<:AbstractMonomial}}","page":"Types","title":"Base.real","text":"real(x::AbstractVector{<:AbstractMonomial})\n\nReturn the real part of x by applying real to all monomials; for this purpose, every complex-valued variable is decomposed into its real- and imaginary parts. Note that the result will no longer be a monomial vector.\n\nSee also imag.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.imag-Tuple{AbstractVector{<:AbstractMonomial}}","page":"Types","title":"Base.imag","text":"imag(x::AbstractVector{<:AbstractMonomial})\n\nReturn the imaginary part of x by applying imag to all monomials; for this purpose, every complex-valued variable is decomposed into its real- and imaginary parts. Note that the result will no longer be a monomial vector.\n\nSee also real.\n\n\n\n\n\n","category":"method"},{"location":"types/#Base.isreal-Tuple{AbstractVector{<:AbstractMonomial}}","page":"Types","title":"Base.isreal","text":"isreal(p::AbstractVector{<:AbstractMonomial})\n\nReturns true if and only if every single monomial in p would is real-valued.\n\n\n\n\n\n","category":"method"}]
}
