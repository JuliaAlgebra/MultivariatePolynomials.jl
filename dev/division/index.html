<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Division · MultivariatePolynomials</title><meta name="title" content="Division · MultivariatePolynomials"/><meta property="og:title" content="Division · MultivariatePolynomials"/><meta property="twitter:title" content="Division · MultivariatePolynomials"/><meta name="description" content="Documentation for MultivariatePolynomials."/><meta property="og:description" content="Documentation for MultivariatePolynomials."/><meta property="twitter:description" content="Documentation for MultivariatePolynomials."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MultivariatePolynomials</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../substitution/">Substitution</a></li><li><a class="tocitem" href="../differentiation/">Differentiation</a></li><li class="is-active"><a class="tocitem" href>Division</a><ul class="internal"><li><a class="tocitem" href="#Greatest-Common-Divisor-(GCD)"><span>Greatest Common Divisor (GCD)</span></a></li></ul></li><li><a class="tocitem" href="../internal/">Internal</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Division</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Division</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/master/docs/src/division.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Division"><a class="docs-heading-anchor" href="#Division">Division</a><a id="Division-1"></a><a class="docs-heading-anchor-permalink" href="#Division" title="Permalink"></a></h1><p>Given two polynomials, <span>$p$</span> and <span>$d$</span>, there are unique <span>$r$</span> and <span>$q$</span> such that <span>$p = q d + r$</span> and the leading term of <span>$d$</span> does not divide the leading term of <span>$r$</span>. You can obtain <span>$q$</span> using the <code>div</code> function and <span>$r$</span> using the <code>rem</code> function. The <code>divrem</code> function returns <span>$(q, r)$</span>.</p><p>Given a polynomial <span>$p$</span> and divisors <span>$d_1, \ldots, d_n$</span>, one can find <span>$r$</span> and <span>$q_1, \ldots, q_n$</span> such that <span>$p = q_1 d_1 + \cdots + q_n d_n + r$</span> and none of the leading terms of <span>$q_1, \ldots, q_n$</span> divide the leading term of <span>$r$</span>. You can obtain the vector <span>$[q_1, \ldots, q_n]$</span> using <code>div(p, d)</code> where <span>$d = [d_1, \ldots, d_n]$</span> and <span>$r$</span> using the <code>rem</code> function with the same arguments. The <code>divrem</code> function returns <span>$(q, r)$</span>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.divides" href="#MultivariatePolynomials.divides"><code>MultivariatePolynomials.divides</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">divides(t1::AbstractTermLike, t2::AbstractTermLike)</code></pre><p>Returns whether the monomial of t1 divides the monomial of t2.</p><p><strong>Examples</strong></p><p>Calling <code>divides(2x^2y, 3xy)</code> should return false because <code>x^2y</code> does not divide <code>xy</code> since <code>x</code> has a degree 2 in <code>x^2y</code> which is greater than the degree of <code>x</code> on <code>xy</code>. However, calling <code>divides(3xy, 2x^2y)</code> should return true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/division.jl#L14-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.div_multiple" href="#MultivariatePolynomials.div_multiple"><code>MultivariatePolynomials.div_multiple</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">div_multiple(a, b, ma::MA.MutableTrait)</code></pre><p>Return the division of <code>a</code> by <code>b</code> assuming that <code>a</code> is a multiple of <code>b</code>. If <code>a</code> is not a multiple of <code>b</code> then this function may return anything.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/division.jl#L93-L98">source</a></section></article><p>Note that the coefficients of the polynomials need to be a field for <code>div</code>, <code>rem</code> and <code>divrem</code> to work. If the coefficient type is not a field, it is promoted to a field using <a href="#MultivariatePolynomials.promote_to_field"><code>promote_to_field</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.promote_to_field" href="#MultivariatePolynomials.promote_to_field"><code>MultivariatePolynomials.promote_to_field</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">promote_to_field(::Type{T})</code></pre><p>Promote the type <code>T</code> to a field. For instance, <code>promote_to_field(T)</code> returns <code>Rational{T}</code> if <code>T</code> is an integer and <code>promote_to_field(T)</code> returns <code>RationalPoly{T}</code> if <code>T</code> is a polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/division.jl#L67-L73">source</a></section></article><p>Alternatively, <a href="#MultivariatePolynomials.pseudo_rem"><code>pseudo_rem</code></a> or <a href="#MultivariatePolynomials.pseudo_divrem"><code>pseudo_divrem</code></a> can be used instead as they do not require the coefficient type to be a field.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.pseudo_rem" href="#MultivariatePolynomials.pseudo_rem"><code>MultivariatePolynomials.pseudo_rem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pseudo_rem(f::_APL, g::_APL, algo)</code></pre><p>Return the pseudo remainder of <code>f</code> modulo <code>g</code> as defined in [Knu14, Algorithm R, p. 425].</p><p>See <a href="#MultivariatePolynomials.pseudo_divrem"><code>pseudo_divrem</code></a> for more details.</p><p>[Knu14] Knuth, D.E., 2014. <em>Art of computer programming, volume 2: Seminumerical algorithms.</em> Addison-Wesley Professional. Third edition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/division.jl#L251-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.pseudo_divrem" href="#MultivariatePolynomials.pseudo_divrem"><code>MultivariatePolynomials.pseudo_divrem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pseudo_divrem(f::_APL{S}, g::_APL{T}, algo) where {S,T}</code></pre><p>Return the pseudo divisor and remainder of <code>f</code> modulo <code>g</code> as defined in [Knu14, Algorithm R, p. 425].</p><p>When the coefficient type is not a field, it is not always possible to carry a division. For instance, the division of <code>f = 3x + 1</code> by <code>g = 2x + 1</code> cannot be done over integers. On the other hand, one can write <code>2f = 3g - 1</code>. In general, the <em>pseudo</em> division of <code>f</code> by <code>g</code> is:</p><p class="math-container">\[l f(x) = q(x) g(x) + r(x)\]</p><p>where <code>l</code> is a power of the leading coefficient of <code>g</code> some constant.</p><p>See also <a href="#MultivariatePolynomials.pseudo_rem"><code>pseudo_rem</code></a>.</p><p>[Knu14] Knuth, D.E., 2014. <em>Art of computer programming, volume 2: Seminumerical algorithms.</em> Addison-Wesley Professional. Third edition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/division.jl#L199-L218">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.rem_or_pseudo_rem" href="#MultivariatePolynomials.rem_or_pseudo_rem"><code>MultivariatePolynomials.rem_or_pseudo_rem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rem_or_pseudo_rem(f::_APL, g::_APL, algo)</code></pre><p>If the coefficient type is a field, return <code>rem</code>, otherwise, return <a href="#MultivariatePolynomials.pseudo_rem"><code>pseudo_rem</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/division.jl#L351-L355">source</a></section></article><h2 id="Greatest-Common-Divisor-(GCD)"><a class="docs-heading-anchor" href="#Greatest-Common-Divisor-(GCD)">Greatest Common Divisor (GCD)</a><a id="Greatest-Common-Divisor-(GCD)-1"></a><a class="docs-heading-anchor-permalink" href="#Greatest-Common-Divisor-(GCD)" title="Permalink"></a></h2><p>The Greatest Common Divisor (GCD) and Least Common Multiple (LCM) can be obtained for integers respectively with the <code>gcd</code> and <code>lcm</code> functions. The same functions can be used with monomials and polynomials:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.gcd" href="#Base.gcd"><code>Base.gcd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gcd(m1::AbstractMonomialLike, m2::AbstractMonomialLike)</code></pre><p>Return the largest monomial <code>m</code> such that both <code>divides(m, m1)</code> and <code>divides(m, m2)</code> are <code>true</code>.</p><pre><code class="language- hljs">julia&gt; @polyvar x y z;

julia&gt; gcd(x^2*y^7*z^3, x^4*y^5*z^2)
x²y⁵z²</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/division.jl#L29-L41">source</a></section><section><div><pre><code class="language-julia hljs">function gcd(p1::AbstractPolynomialLike{T}, p2::AbstractPolynomialLike{S}) where {T, S}</code></pre><p>Returns a greatest common divisor of <code>p1</code> and <code>p2</code>. Note that it does not make sense, in general, to speak of &quot;the&quot; greatest common divisor of u and v; there is a set of greatest common divisors, each one being a unit multiple of the others [Knu14, p. 424].</p><p><strong>Implementation notes</strong></p><p>The classical algorithm for computing the <code>gcd</code>, commonly referred to as the Euclidean Algorithm is to use a recursion with the base case <code>gcd(p, 0) = p</code> and the relation <code>gcd(p1, p2) = gcd(p2, rem(p1, p2))</code>. The relation comes from the Euclidean division: <code>p1 = q * p2 + r</code>, if <code>g</code> divides <code>p1</code> and <code>p2</code> then it divides <code>r</code> and if <code>g</code> divides <code>r</code> and <code>p2</code> then it divides <code>p1</code>.</p><p>For multivariate polynomials, you may have <code>rem(p1, p2) = p1</code> hence this will not terminate. To ensure we make progress, we can pick a given variable <code>xi</code> and try to find <code>q1</code> and <code>q2</code> such that <code>q2 * p1 = q1 * p2 + r</code> and the degree of <code>r</code> in <code>xi</code> is strictly smaller than the degree of <code>p1</code> in <code>xi</code>. Note that if <code>g</code> divides <code>p1</code> and <code>p2</code> then it divides <code>r</code> but if <code>g</code> divides <code>r</code> and <code>p2</code> then it might divide <code>q2</code> and not <code>p1</code>. So what do we do ? Let <code>dj</code> be the degree of <code>pj</code> in <code>xi</code>. Suppose we pick <code>qj</code> to be the coefficient of <code>pj</code> in <code>xi^dj</code>. If <code>g</code> divides <code>q2</code> then it means that the degree of <code>g</code> in <code>xi</code> is zero. Therefore, if it divides <code>p2</code> then it also divides the coefficients of <code>p2</code> in <code>xi^k</code> for <code>k = 0, 1, ..., d2</code>. This means that if we ensure that these are relatively prime then we won&#39;t have any issue. So we start by computing a <code>gcd</code> <code>gj</code> of the coefficients in each degree of <code>xi</code> of <code>pj</code>, this is called the <a href="#MultivariatePolynomials.content"><code>content</code></a> of <code>pj</code>. And then we compute <code>_gcd(p1 / g1, p2 / g2) * gcd(g1, g2)</code> where we can use the recursion <code>_gcd(p1, p2) = _gcd(p2, q2 * p1 - q1 * p2)</code> where <code>q1, q2</code> are as defined above. This is the <a href="#MultivariatePolynomials.GeneralizedEuclideanAlgorithm"><code>GeneralizedEuclideanAlgorithm</code></a>.</p><p>[Knu14] Knuth, D.E., 2014. <em>Art of computer programming, volume 2: Seminumerical algorithms.</em> Addison-Wesley Professional. Third edition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L124-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.lcm" href="#Base.lcm"><code>Base.lcm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">lcm(m1::AbstractMonomialLike, m2::AbstractMonomialLike)</code></pre><p>Return the smallest monomial <code>m</code> such that both <code>divides(m1, m)</code> and <code>divides(m2, m)</code> are <code>true</code>.</p><pre><code class="language- hljs">julia&gt; @polyvar x y z;

julia&gt; lcm(x^2*y^7*z^3, x^4*y^5*z^2)
x^4*y^7*z^3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/division.jl#L46-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.AbstractUnivariateGCDAlgorithm" href="#MultivariatePolynomials.AbstractUnivariateGCDAlgorithm"><code>MultivariatePolynomials.AbstractUnivariateGCDAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractUnivariateGCDAlgorithm end</code></pre><p>Algorithm computing the greatest common divisor of univariate polynomials. See <a href="#MultivariatePolynomials.GeneralizedEuclideanAlgorithm"><code>GeneralizedEuclideanAlgorithm</code></a> and <a href="#MultivariatePolynomials.SubresultantAlgorithm"><code>SubresultantAlgorithm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.GeneralizedEuclideanAlgorithm" href="#MultivariatePolynomials.GeneralizedEuclideanAlgorithm"><code>MultivariatePolynomials.GeneralizedEuclideanAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct GeneralizedEuclideanAlgorithm &lt;: AbstractUnivariateGCDAlgorithm
    primitive_rem::Bool
    skip_last::Bool
end</code></pre><p>Algorithm computing the greatest common divisor of univariate polynomials using the Euclidean algorithm generalized for polynomials with coefficients over a a unique factorization domain, see [Knu14, Algorithm E, p. 426-427].</p><p>If <code>primitive_rem</code> is <code>true</code>, the intermediate remainders produced in the polynomial division are made primitive. If <code>primitive_part</code> is set to <code>false</code>, only the resuting remainder is made primitive (the intermediate remainders of the generalized Euclidean algorithm still need to be made primitive).</p><p>[Knu14] Knuth, D.E., 2014. <em>Art of computer programming, volume 2: Seminumerical algorithms.</em> Addison-Wesley Professional. Third edition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L13-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.SubresultantAlgorithm" href="#MultivariatePolynomials.SubresultantAlgorithm"><code>MultivariatePolynomials.SubresultantAlgorithm</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct SubresultantAlgorithm &lt;: AbstractUnivariateGCDAlgorithm
    skipped_divisions::Int
end</code></pre><p>Algorithm computing the greatest common divisor of univariate polynomials using the Subresultant algorithm, see [Knu14, Algorithm C, p. 428-429].</p><p>The division by <code>g*h^δ</code> in the algorithm only works if the iteration of [Knu14, Algorithm R, p. 426] is carried out even when the divided polynomial has a zero term. For computational savings, we don&#39;t do that so we store in <code>skipped_division</code> the number of skipped divisions so that the division by <code>g*h^δ</code> can be adapted accordingly.</p><p>In [Knu14, Algorithm C, p. 426], it is stated that there should be ``</p><p>[Knu14] Knuth, D.E., 2014. <em>Art of computer programming, volume 2: Seminumerical algorithms.</em> Addison-Wesley Professional. Third edition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L47-L66">source</a></section></article><p>Internal functions of the <code>gcd</code> algorithm:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.isolate_variable" href="#MultivariatePolynomials.isolate_variable"><code>MultivariatePolynomials.isolate_variable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isolate_variable(poly::_APL, var::AbstractVariable, mutability::MA.MutableTrait)</code></pre><p>Returns a polynomial with variable <code>var</code>. The other variables of <code>poly</code> are moved as coefficients.</p><p>The output can be mutated without affecting <code>poly</code> if <code>mutability</code> is <code>MA.IsNotMutable</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L473-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.primitive_univariate_gcd!" href="#MultivariatePolynomials.primitive_univariate_gcd!"><code>MultivariatePolynomials.primitive_univariate_gcd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">primitive_univariate_gcd!(p::_APL, q::_APL, algo::AbstractUnivariateGCDAlgorithm)</code></pre><p>Returns the <code>gcd</code> of primitive polynomials <code>p</code> and <code>q</code> using algorithm <code>algo</code> which is a subtype of <a href="#MultivariatePolynomials.AbstractUnivariateGCDAlgorithm"><code>AbstractUnivariateGCDAlgorithm</code></a>. The function might modify <code>p</code> or <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L533-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.univariate_gcd" href="#MultivariatePolynomials.univariate_gcd"><code>MultivariatePolynomials.univariate_gcd</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">univariate_gcd(p1::AbstractPolynomialLike, p2::AbstractPolynomialLike, algo::AbstractUnivariateGCDAlgorithm)</code></pre><p>Return the <em>greatest common divisor</em> of the polynomials <code>p1</code> and <code>p2</code> that have at most one variable in common and for which the coefficients are either <code>AbstractFloat</code> or part of a unique factorization domain, e.g., rational numbers, integers or multivariate polynomials. So <code>p1</code> and <code>p2</code> should have at most one variable in common but their coefficients can be multivariate polynomials that share arbitrarily many variables.</p><p>If the coefficients are not <code>AbstractFloat</code>, this</p><ol><li>separates <code>p1</code> and <code>p2</code> in their <a href="#MultivariatePolynomials.content"><code>content</code></a> and <a href="#MultivariatePolynomials.primitive_part"><code>primitive_part</code></a> using <a href="#MultivariatePolynomials.primitive_part_content"><code>primitive_part_content</code></a>; see [Knu14, Algorithm E: E1, p. 426] or [Knu14, Algorithm C: C1, p. 428].</li><li>Computes the <a href="#Base.gcd"><code>gcd</code></a> of the contents and primitive parts, using <a href="#MultivariatePolynomials.primitive_univariate_gcd!"><code>primitive_univariate_gcd!</code></a> for primitive parts.</li><li>Return the product of these two <code>gcd</code>; see [Knu14, Algorithm E: E4, p. 427] or [Knu14, Algorithm C: C4, p. 429].</li></ol><p>[Knu14] Knuth, D.E., 2014. <em>Art of computer programming, volume 2: Seminumerical algorithms.</em> Addison-Wesley Professional. Third edition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L725-L747">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.content" href="#MultivariatePolynomials.content"><code>MultivariatePolynomials.content</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">content(poly::AbstractPolynomialLike{T}, algo::AbstractUnivariateGCDAlgorithm, mutability::MA.MutableTrait) where {T}</code></pre><p>Return the <em>content</em> of the polynomial <code>poly</code> over a unique factorization domain <code>S</code> as defined in [Knu14, (3) p. 423]. That is, return the <code>gcd</code> of the coefficients of <code>poly</code>. See also <a href="#MultivariatePolynomials.primitive_part_content"><code>primitive_part_content</code></a>.</p><p>The output can be mutated without affecting <code>poly</code> if <code>mutability</code> is <code>MA.IsNotMutable</code>.</p><p>[Knu14] Knuth, D.E., 2014. <em>Art of computer programming, volume 2: Seminumerical algorithms.</em> Addison-Wesley Professional. Third edition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L860-L874">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.primitive_part" href="#MultivariatePolynomials.primitive_part"><code>MultivariatePolynomials.primitive_part</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">primitive_part(poly::AbstractPolynomialLike{T}, algo::AbstractUnivariateGCDAlgorithm) where {T}</code></pre><p>Return the <em>primitive part</em> of the polynomial <code>poly</code> over a unique factorization domain <code>S</code> as defined in [Knu14, (3) p. 423]. That is, return the exact division of <code>poly</code> by its <a href="#MultivariatePolynomials.content"><code>content</code></a>. If the content is also needed, call <a href="#MultivariatePolynomials.primitive_part_content"><code>primitive_part_content</code></a> instead.</p><p>[Knu14] Knuth, D.E., 2014. <em>Art of computer programming, volume 2: Seminumerical algorithms.</em> Addison-Wesley Professional. Third edition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L930-L942">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MultivariatePolynomials.primitive_part_content" href="#MultivariatePolynomials.primitive_part_content"><code>MultivariatePolynomials.primitive_part_content</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">primitive_part_content(poly::AbstractPolynomialLike{T}, algo::AbstractUnivariateGCDAlgorithm) where {T}</code></pre><p>Return the <em>primitive part</em> and <em>content</em> of the polynomial <code>poly</code> over a unique factorization domain <code>S</code> as defined in [Knu14, (3) p. 423]. This is more efficient to call this function rather than calling <a href="#MultivariatePolynomials.primitive_part"><code>primitive_part</code></a> and <a href="#MultivariatePolynomials.content"><code>content</code></a> separately since computing the primitive part requires computing the content first and this function avoid computing the content twice.</p><p>[Knu14] Knuth, D.E., 2014. <em>Art of computer programming, volume 2: Seminumerical algorithms.</em> Addison-Wesley Professional. Third edition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl/blob/9fc5d7d0086206e82bd83002dd75a63bd6e7c0e2/src/gcd.jl#L958-L970">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../differentiation/">« Differentiation</a><a class="docs-footer-nextpage" href="../internal/">Internal »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Thursday 1 May 2025 06:02">Thursday 1 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
